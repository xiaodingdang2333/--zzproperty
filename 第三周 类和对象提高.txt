静态成员函数由于不具体作用于某个对象，所以不能使用this指针。  

普通成员变量每个对象有各自的一份，而静态成员变
量一共就一份，为所有对象共享。
sizeof 运算符不会计算静态成员变量。

如何访问静态成员：
1) 类名::成员名
CRectangle::PrintTotal();
2) 对象名.成员名
CRectangle r; r.PrintTotal();
3) 指针->成员名
CRectangle * p = &r; p->PrintTotal();
4) 引用.成员名
CRectangle & ref = r; int n = ref.nTotalNumber; 

设置静态成员这种机制的目的是将和某些类紧密相关的全局变
量和函数写到类里面，看上去像一个整体，易于维护和理解。
静态成员变量本质上是全局变量，哪怕一个对象都不存在，类
的静态成员变量也存在。
静态成员函数本质上是全局函数。

c++里的静态成员变量要拿到类外面进行声明，可以初始化也可以不初始化
类的private只能由公有成员函数、友元函数访问

静态成员函数不能访问非静态成员变量和非静态成员函数。

一个类的成员是其他类的对象，这个对象叫成员对象，包含成员对象的类叫封闭类。
任何生成封闭类对象的语句，都要让编译器明白，对象中的成员对象，是如何
初始化的。

封闭类对象生成时，先执行所有对象成员的构造函数，然后才执
行封闭类的构造函数。当封闭类的对象消亡时，次序和构造函数的调用次序相反。

成员函数后面加const 为常量成员函数
因为常量成员函数在执行期间不能修改其所作用的对象，因此在常量成员函数中不能修改成员变量的值，也不能调用同类的非常量成员函数。

重载和覆盖：
相同：都要求方法同名
不同：覆盖就是子类里一个除了函数体的内容，其他部分和父类的函数一模一样。重载则是用于同一类中的所有函数，且要求参数列表必须不一样。

类的私有成员只能由类本身的函数访问，或者利用友元访问，而类的静态成员函数因为没有this指针，因此只能访问显式参数的私有成员。
class t{
private:
    int member;
public:
    static int func(t obj){
    //return member;       不可以
    //return this->member; 不可以
    return obj.member;   //可以
    }
};

友元关系不能传递 不能继承




